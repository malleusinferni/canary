use ast::*;
//use token::*;
use super::Error;

grammar;

pub module: Module = {
    <begin:stmt*> <defs:def*> => {
        let begin = begin.into_iter().filter_map(|a| a).collect();
        Module { begin, defs }
    },
};

pub def: Def = {
    "sub" <name:near_word> "(" <args:comma<var>?> ")" <body:block> => {
        let args = Args(args.unwrap_or_else(|| vec![]));
        Def { name, args, body }
    },
};

block: Vec<Stmt> = {
    "{" <block_body> "}",
};

pub block_body: Vec<Stmt> = {
    <stmt*> => (<>).into_iter().filter_map(|a| a).collect(),
};

stmt: Option<Stmt> = {
    <simple_stmt?> ";" => (<>),

    <block_stmt> => Some(<>),
};

simple_stmt: Stmt = {
    "my" <lhs:var> <rhs:("=" <expr>)?> => {
        Stmt::My { lhs, rhs }
    },

    <lhs:expr> "=" <rhs:expr> => {
        Stmt::Assign { lhs, rhs }
    },

    "return" <rhs:expr?> => {
        Stmt::Return { rhs }
    },

    <rhs:expr> => {
        Stmt::Bare { rhs }
    },

    <name:far_word> <args:comma<expr>?> => {
        let args = args.unwrap_or(vec![]);
        let rhs = Expr::Call { name, args };
        Stmt::Bare { rhs }
    },
};

block_stmt: Stmt = {
    "if" <first:(<expr> <block>)>
        <rest:("else" "if" <expr> <block>)*>
        <last:("else" <block>)?>
        =>
    {
        let mut clauses = vec![first];
        clauses.extend(rest.into_iter());
        let last = last.unwrap_or(vec![]);
        Stmt::If { clauses, last }
    },

    "while" <test:expr> <body:block> => {
        Stmt::While { test, body }
    },
};

expr: Expr = {
    <lhs:term> "+" <rhs:expr> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Add,
        }
    },

    <lhs:term> "-" <rhs:expr> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Sub,
        }
    },

    <term> => <>,
};

term: Expr = {
    <lhs:factor> "*" <rhs:term> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Mul,
        }
    },

    <lhs:factor> "/" <rhs:term> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Div,
        }
    },

    <lhs:factor> "=~" <rhs:factor> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Match,
        }
    },

    <factor> => <>,
};

factor: Expr = {
    <int> => Expr::Literal(Literal::Int(<>)),

    <string> => Expr::Literal(Literal::Str(<>)),

    <var> => Expr::Local(<>),

    <global> => Expr::Global(<>),

    <pattern> => Expr::Literal(Literal::Pattern(<>)),

    <name:near_word> "(" <args:comma<expr>?> ")" => {
        let args = args.unwrap_or_else(|| vec![]);
        Expr::Call { name, args }
    },

    <lhs:factor> "[" <rhs:expr> "]" => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Idx,
        }
    },

    <lhs:factor> "." <idx:far_word> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(Expr::Literal(Literal::Ident(idx)));
        let op = Binop::Idx;
        Expr::Binop { lhs, rhs, op }
    },

    "[" <comma<expr>?> "]" => Expr::List((<>).unwrap_or(vec![])),

    "(" <expr> ")" => <>,
};

#[inline]
comma<T>: Vec<T> = {
    <many:(<T> ",")*> <last:T> => {
        let mut many = many;
        many.push(last);
        many
    },
};

extern {
    type Location = usize;
    type Error = Error;

    enum Token {
        "return" => Token::RETURN,
        "sub" => Token::DEF,
        "my" => Token::LET,
        "if" => Token::IF,
        "else" => Token::ELSE,
        "while" => Token::WHILE,
        "(" => Token::LPAR,
        ")" => Token::RPAR,
        "[" => Token::LSQB,
        "]" => Token::RSQB,
        "{" => Token::LCBR,
        "}" => Token::RCBR,
        ":" => Token::COLON,
        "=" => Token::EQUAL,
        "=~" => Token::MATCH,
        ";" => Token::EOL,
        "," => Token::COMMA,
        "." => Token::DOT,
        "+" => Token::ADD,
        "-" => Token::SUB,
        "/" => Token::DIV,
        "*" => Token::MUL,
        int => Token::INT(<Int>),
        near_word => Token::NEARWORD(<Ident>),
        far_word => Token::FARWORD(<Ident>),
        global => Token::GLOBAL(<Ident>),
        var => Token::VAR(<Ident>),
        string => Token::STR(<Str>),
        pattern => Token::PAT(<Pattern>),
    }
}

// vim: ft=rust
