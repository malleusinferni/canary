use ast::*;
//use token::*;
use super::Error;

grammar;

pub module: Vec<Def> = {
    <items:def*> => items,
};

pub def: Def = {
    "sub" <name:ident> "(" <args:comma<ident>?> ")" <body:block> => {
        let args = Args(args.unwrap_or_else(|| vec![]));
        Def { name, args, body }
    },
};

block: Vec<Stmt> = {
    "{" <block_body> "}",
};

pub block_body: Vec<Stmt> = {
    <stmt*> => (<>).into_iter().filter_map(|a| a).collect(),
};

stmt: Option<Stmt> = {
    <simple_stmt?> ";" => (<>),

    <block_stmt> => Some(<>),
};

simple_stmt: Stmt = {
    "my" <lhs:ident> <rhs:("=" <expr>)?> => {
        Stmt::My { lhs, rhs }
    },

    <lhs:ident> "=" <rhs:expr> => {
        Stmt::Assign { lhs, rhs }
    },

    "return" <rhs:expr?> => {
        Stmt::Return { rhs }
    },

    <rhs:expr> => {
        Stmt::Bare { rhs }
    },
};

block_stmt: Stmt = {
    "if" <first:(<expr> <block>)>
        <rest:("else" "if" <expr> <block>)*>
        <last:("else" <block>)?>
        =>
    {
        let mut clauses = vec![first];
        clauses.extend(rest.into_iter());
        let last = last.unwrap_or(vec![]);
        Stmt::If { clauses, last }
    },
};

expr: Expr = {
    <lhs:term> "+" <rhs:expr> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Add,
        }
    },

    <lhs:term> "-" <rhs:expr> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Sub,
        }
    },

    <term> => <>,
};

term: Expr = {
    <lhs:factor> "*" <rhs:term> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Mul,
        }
    },

    <lhs:factor> "/" <rhs:term> => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Div,
        }
    },

    <lhs:factor> "[" <rhs:expr> "]" => {
        Expr::Binop {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op: Binop::Idx,
        }
    },

    <factor> => <>,
};

factor: Expr = {
    <int> => Expr::Literal(Literal::Int(<>)),

    <string> => Expr::Literal(Literal::Str(<>)),

    <ident> => Expr::Name(<>),

    <name:ident> "(" <args:comma<expr>?> ")" => {
        let args = args.unwrap_or_else(|| vec![]);
        Expr::Call { name, args }
    },

    "[" <comma<expr>> "]" => Expr::Literal(Literal::List(<>)),

    "(" <expr> ")" => <>,
};

#[inline]
comma<T>: Vec<T> = {
    <many:(<T> ",")*> <last:T> => {
        let mut many = many;
        many.push(last);
        many
    },
};

extern {
    type Location = usize;
    type Error = Error;

    enum Token {
        "return" => Token::RETURN,
        "sub" => Token::DEF,
        "my" => Token::LET,
        "if" => Token::IF,
        "else" => Token::ELSE,
        "(" => Token::LPAR,
        ")" => Token::RPAR,
        "[" => Token::LSQB,
        "]" => Token::RSQB,
        "{" => Token::LCBR,
        "}" => Token::RCBR,
        ":" => Token::COLON,
        "=" => Token::EQUAL,
        ";" => Token::EOL,
        "," => Token::COMMA,
        "+" => Token::ADD,
        "-" => Token::SUB,
        "/" => Token::DIV,
        "*" => Token::MUL,
        int => Token::INT(<Int>),
        ident => Token::ID(<Ident>),
        string => Token::STR(<Str>),
    }
}

// vim: ft=rust
